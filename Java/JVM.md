<img src="image/jvm_main.png" width=100% height="400">

# JVM

> Java Virtual Machine의 약자로 프로그램을 실행 시키기 위해 물리적 머신(컴퓨터)과 비슷하게 소프트웨어로 구현한 것이다.

### 사용 이유

우선 Java의 탄생 배경부터 알아야한다.  
기존의 C/C++의 경우, 여러가지 하드웨어를 커버하기 위해서는 각 하드웨어에 맞게 전부 다르게 프로그래밍을 해야되는 어려움이 존재하였다.  
어느 하드웨어에서나 같은 코드로 돌리기 위해서 JVM이란 것을 고안하게 되었고, 이는 JAVA의 큰 특징인 어느 플랫폼에도 종속적이지 않게 되었다.

---

### 특징

* 스택 기반으로 동작하는 가상 머신
* 기본 자료형을 제외한 모든 타입을 명시적인 메모리 주소 기반의 레퍼런스가 아닌 심볼릭 레퍼런스를 통해 참조
* [Garbage Collection](/Java/GC.md)이란 것을 사용하여 사용자에 의해 생성된 클래스 인스턴스를 자동으로 파괴
* 기본 자료형을 명확하게 정의하여 플랫폼에 종속적이지 않음을 보장
* 네트워크 바이트 오더(빅 [엔디안](https://ko.wikipedia.org/wiki/엔디언))를 사용

---

### 구조

<img src="https://d2.naver.com/content/images/2015/06/helloworld-1230-1.png">

출처 : [JVM Internal](https://d2.naver.com/helloworld/1230)

Java 코드가 실행되는 전체 과정은 위 그림과 같으며, 빨간색 네모가 JVM이다.

일단, 우리가 코딩한 Java 파일을 `Java Compiler`가 Byte code로 컴파일을 진행한다.  
Byte code(.class)로 변경하는 이유는 JVM이 해석할 수 있도록 만들기 위함이다.(기계어로 변경하는 이유와 동일)  
이렇게 변경된 파일(.class)을 **클래스 로더(Class Loader)**가 **런타임 데이터 영역(Runtime Data Areas)**에 로드하며, **실행 엔진(Execution Engine)**은 바이트 코드를 기계어로 변경하여 수행을 한다.

---

### Class Loader

자바의 경우 컴파일 타임에 클래스를 로드하고 참조하는 것이 아닌 런타임에 클래스를 로드&참조한다.   
이를 동적 로딩이라고 하는데, JVM에서 이를 맞고 있는 부분이 바로 `Class Loader`이다.

클래스 로더는 다음과 같은 몇가지 특징을 가지고 있다.

* 클래스 로더끼리 부모-자식 관계를 이루어 계층 구조로 생성  
  최상위 클래스 로더는 부트스트랩 클래스 로더(Bootstrap Class Loader) 
* 계층 구조를 이용하여 클래스 로더끼리 로드를 위임하는 식으로 동작
  * 동작 방식(클래스 로드 시)
    1. 캐시가 되어있는지 확인
    2. 없다면 상위 클래스 로더에 확인(1번 과정 동일)
    3. 2번 과정을 최상위 클래스 로더까지 실행
    4. 최상위 클래스 로더(Bootstrap Class Loader)에도 없다면 요청 받은 클래스 로더가
       파일 시스템에서 해당 클래스를 찾음
* 하위 클래스 로더는 상위 클래스 로더를 찾을 수 있지만, 상위 클래스 로더는 하위 클래스 로더를 찾을 수 없음
* 클래스 로더는 클래스를 로드 할 수 있지만, 그 반대인 언로드는 불가능



#### Class Loader 종류

<img src ="https://d2.naver.com/content/images/2015/06/helloworld-1230-2.png">

출처 : [JVM Internal](https://d2.naver.com/helloworld/1230)

* 부트스트랩 클래스 로더

  > JVM을 실행할 때 생성되며, Object 클래스를 비롯하여 JAVA API를 로드
  >
  > 다른 로더와 다르게 네이티브 코드로 구현

* 익스텐션 클래스 로더(Extension Class Loader)

  > 기본 JAVA API를 제외한 확장 클래스를 로드

* 시스템 클래스 로더(System Class Loader)

  > 위 두개의 로더가 JVM 자체의 구성 요소를 로드하는 것이라면, 시스템 클래스 로더는 애플리케이션의 클래스를 로드
  >
  > 사용자가 지정한 $CLASSPATH 내의 클래스를 로드

* 사용자 정의 클래스 로더(User-Defined Class Loader)

  > 애플리케이션 사용자가 직접 코드 상에서 생성해서 사용하는 클래스 로더

#### 로드 과정(링크)

1. 로드(Loading)
  
   > 클래스를 파일에서 가져와 JVM 메모리에 로드
   
2. 검증(Verifying)
  
   > 읽은 클래스가 자바 언어 명세 및 JVM 명세에 명시된 것처럼 잘 구성되었는지 검사  
   > 로드 과정중 가장 까다로운 과정, 시간을 가장 많이 소모
   
3. 준비(Preparing)
  
   > 클래스가 필요로 하는 메모리를 할당, 클래스에서 정의 된 필드, 메소드, 인터페이스들을 나나태는 데이터 구조 준비
   
4. 분석(Resolving)

   > 클래스의 상수 풀 내의 모든 심볼릭 레퍼런스를 다이렉트 레퍼런스로 변경

5. 초기화(Initializing)

   > 클래스 변수들을 적절한 값으로 초기화

---

### Runtime Data Areas

<img src="https://d2.naver.com/content/images/2015/06/helloworld-1230-4.png">

출처 : [JVM Internal](https://d2.naver.com/helloworld/1230)

런타임 데이터 영역은 JVM이 OS 위에서 실행되며 할당받는 메모리 영역이다.  
총 6개의 영역으로 나뉠 수 있는데, 이 중 PC Register, JVM Stack, Native Method Stack의 경우 스레드 마다 하나씩 생성되며 나머지(Heap, Method Area, Runtime Constant Pool)은 모든 스레드가 공유해서 사용한다.

#### PC Register

스레드가 생성될 때마다 생성되는 공간으로 스레드가 어떤 명령을 실행할 것인지 해당 명령에 대한 주소를 가지고 있다.

#### JVM Stack

스레드가 시작될 때 생성되며 스택 프레임(Stack Frame)이라는 구조체를 저장하는 공간이다.  
이름과 동일하게 Stack 자료구조로 되어있으며, 각각의 프레임은 LIFO 순으로 삽입 삭제된다.

* **스택 프레임**

  JVM 내에서 메소드가 수행될 때마다 하나의 스택 프레임이 생성되며 JVM Stack에 추가된다.  
  메소드가 종료되면 스택 프레임은 제거되며 내부에 **지역 변수 배열**, **피연산자 스택**, **런타임 상수 풀에 대한 참조**가 존재한다.

  <img src="image/jvm_stack_frame.png" width="800">

* **지역 변수 배열**  

  0부터 시작하는 인덱스를 가진 배열로 지역 변수가 저장되는 공간

  0 번째 인덱스에는 메소드가 속한 클래스 인스턴스의 this 레퍼런스 저장  
  1 ~ N 번째 까지는 메소드에 전달된 파라미터 저장  
  N 번째 이후부터는 지역 변수들이 저장 

* **피연산자(Operand) 스택**

  메소드를 실행하는 실제 공간으로 메소드안에서 일어나는 명령의 결과들을 push 하거나 pop한다.  
  각각의 메소드는 피연산자 스택과 지역 변수 배열 사이에서 데이터를 교환한다. 

  ```java
  public int add() {
    int a = 1;
    int b = 2;
    return a + b;
  }
  /*
  바이트 코드
  int add();
     Code:
         0: iconst_1
         1: istore_0
         2: iconst_2
         3: istore_1
         4: iload_0
         5: iload_1
         6: iadd
         7: ireturn
  */
  ```

  피연산자의 과정을 자세하게 알고싶다면 바이트 코드로 변환된 코드를 보면 알 수 있다.

  1. 상수 1을 피연산자 스택에 push - 0
  2. 피연산자 스택 pop 후에 지역 변수 배열에 저장(a) - 1
  3. 상수 2를 피연산자 스택에 push - 2
  4. pop 후에 지역 변수 배열에 저장(b) - 3
  5. 지역 변수 배열에서 a, b를 읽어 더한 값을 반환 - 4,5,6,7

* **런타임 상수 풀에 대한 참조**

  이는 이름 그대로 현재 프레임이 속한 클래스의 런타임 상수 풀에 대해 참조이며, 해당 클래스의 런타임 상수 풀에 접근이 가능하도록 한다.

#### Native Method Stack

자바 이외의 언어로 작성된 네이티브 코드를 위한 스택이며 필수로 가지고 있지 않아도 된다.

#### Heap

인스턴스 또는 객체를 저장하는 공간으로 JVM 성능에 가장 영향을 미친다.  
그렇기 때문에 Garbage Collection는 이 힙 영역에 필요없는 객체/인스턴스들을 정리한다.  
이러한 힙의 구성 방식과 GC의 방법은 JVM마다 다르다.

#### Method Area

JVM이 시작될 때 생성되며 JVM이 읽어들인 각각의 클래스와 인터페이스에 대한 정보들을 보관한다.
오라클의 Hotspot JVM에서는 Metaspace라는 메소드 영역이 존재한다.(java 7 이전의 Permanent Generation)

#### Run-Time Constant Pool

메소드 영역에 포함되는 영역으로 JVM 동작에서 가장 핵심적인 역할을 수행하는 곳으로 각 클래스와 인터페이스의 상수와 메소드와 필드에 대한 모든 레퍼런스까지 담고 있는 테이블이다.  
즉, 메소드나 필드를 참조할 경우 JVM에서는 런타임 상수 풀을 통해 해당 메소드나 필드의 실제 메모리 주소를 찾아 참조한다.

---

### Execution Engine

JVM 내의 런타임 데이터 영역에 배치된 바이트 코드들은 실행 엔진에 의해 실행된다.  
실행 엔진은 바이트 코드를 명령어 단위로 읽어 실행한다.(기계어를 하나씩 실행하는 방식과 동일)

바이트 코드의 경우, 기계어가 아니므로 실행 엔진에 의해 기계어로 변경되는데 2가지 방식이 존재한다.

* 인터프리터

  > 바이트 코드를 하나씩 읽어 해석하며 실행  
  > 하나하나의 실행은 빠른대신 전체를 실행하는데에는 느리다는 단점 보유

* JIT(Just-In-Time) 컴파일러

  > 인터프리터의 단점을 보완하기위해 도입  
  > 인터프리터 방식으로 컴파일을 하다 일정 시점에서 바이트 코드 전체를 컴파일  
  > 변경된 네이티브 코드는 캐시에 보관되어 빠르게 수행 가능  
  >
  > 하지만, 한번만 실행되는 코드라면 JIT 방식보다는 인터프리터 방식이 유리

---

<br>

### Reference

* [NAVER D2 - JVM Internal](https://d2.naver.com/helloworld/1230)
* [JVM stack과 frame - 기계인간 John Grib](https://johngrib.github.io/wiki/jvm-stack/)

