# 2. 코틀린 기초

> 🧛🏽‍♂️ 이 글은 "Kotlin In Action"을 공부하며 정리한 내용이며, 문제시 삭제 될 수 있음을 알립니다.

<br>

## 2.1 기본 요소: 함수와 변수

```java
fun main(args: Array<String>) {
    println("Hello, world!")
}
```

* 함수를 선언할 때 `fun` 키워드를 사용(코틀린 프로그래밍은 수많은 `fun`을 만드는 재밌는 일!)
* 파라미터 이름 뒤에 타입을 작성
* 함수를 최상위 수준에 정의할 수 있으며 꼭 클래스 안에 함수를 넣어야 할 필요가 없음
* 배열도 일반적인 클래스와 같으나 코틀린에는 자바와 달리 배열 처리를 위한 문법이 따로 존재하지 않음
* 코틀린 표준 라이브러리는 여러 가지 표준 자바 라이브러리 함수를 간결하게 사용할 수 있게 감싼 래퍼를 제공  
  (ex → `println`)
* 줄 끝에 세미콜론을 붙이지 않아도 좋음

### 2.1.2 함수

* 함수 선언은 `fun` 키워드로 시작, 다음으로는 함수 이름
* 이름 뒤에는 괄호 안에 파라미터 목록, 그 뒤에는 반환 타입이 오는데 콜론으로 구분

#### 식이 본문인 함수

* 코틀린에서는 `if`는 식이지 문이 아님

* 식은 값을 만들어 내며 다른 식의 하위 요소로 계산에 참여 가능

* 문은 자신을 둘러싸고 있는 가장 안쪽 블록의 최상위 요소로 존재하며 아무런 값을 만들어내지 않음

* 만약 함수를 한줄로 나타낼 수 있다면 중괄호와 `return`을 제거하면서 등호(=)를 식 앞에 붙혀 표현 가능

  ```kotlin
  fun max(a: Int, b: Int): Int = if(a > b) a else b
  ```

* 굳이 사용자가 반환 타입을 적지 않아도 컴파일러가 함수 본문 식을 분석하여 식의 결과 타입을 함수 반환 타입으로 정해줌 이를 타입 추론이라고 함

### 2.1.3 변수

* 코틀린에서는 타입 지정을 생략하는 경우가 흔함
* 타입으로 변수 선언을 시작한다면 타입을 생략할 경우와 헷갈림  
  따라서 코틀린에서는 키워드로 변수 선언을 시작하는 대신 뒤에 타입을 생략할 수 있도록 허용
* 초기화 식을 사용하지 않고 변수를 선언하려면 변수 타입을 반드시 명시  
  만약 없다면 컴파일러가 타입 추론을 할 수 있는 정보가 아무것도 없음

#### 변경 가능한 변수와 변경 불가능한 변수

* `val`
  * 변경 불가능한 참조를 저장하는 변수
  * 다시 대입이 불가능(자바에서 `final`)
* `var`
  * 변경 가능한 참조
  * 자바의 일반 변수에 해당
* 기본적으로 모든 변수를 `val` 키워드를 사용해 불변 변수로 선언하고 꼭 필요할 때만 `var`를 사용  
  이를 통해 불변 함수와 불변 변수를 통해 함수형 코드에 가까워 짐
* `val`는 조건에 따라 여러 값으로 초기화할 수 있음
* `val` 참조 자체는 불변일지라도 그 참조가 가리키는 객체의 내부 값은 변경될 수 있음
* `var` 키워드를 사용하면 변수의 값을 변경할 수 있지만 변수의 타입은 고정돼 바뀌지 않음
* 컴파일러의 경우 변수 선언 시점의 초기화 식으로 타입을 추론하고 이를 기반으로 재대입시 해당 타입으로 검사
* 만약 다른 타입으로 변환하고 싶으면 변환 함수 혹은 강제 형 변환을 해야 함

### 2.1.4 더 쉽게 문자열 형식 지정: 문자열 템플릿

```kotlin
fun main(args: Array<String>) {
    val name = "jongnan"
    println("Hello, $name!")
}
```

* 다음과 같이 변수를 문자 안에 사용할 수 있는 것을 문자열 템플릿이라고 하고 변수 앞에 `$`를 추가
* 자바 문자열 접합 연산을 사용한 식과 마찬가지로 효율적
* 만약 `$`를 문자로 표현하고 싶다면 `\`를 사용하여 이스케이프 해야 함
* 한글을 사용시 문제가 발생할 수 있으며 가독성을 위해 변수를 나타낼 때는 `{}` 를 사용하여 구분을 하는 것이 좋음

<br>

## 2.2 클래스와 프로퍼티

```kotlin
// java
public class Person {
    private final String name;
    public Person(String name) {
        this.name = name;
    }
    public String getName() {
        return name;
    }
}

// kotlin
class Person(val name: String)
```

* 위와 같이 여러 줄의 자바 코드를 한 줄의 코틀린 코드로 줄일 수 있음
* 코드가 없이 데이터만 저장하는 클래스를 값 객체라고 부름
* 코틀린의 기본 가시성은 `public`이므로 해당 경우 생략 가능

### 2.2.1 프로퍼티

* 코틀린에서 프로퍼티를 기본으로 제공하며 자바의 필드와 접근자 메소드를 완전히 대신  
  즉, 게터와 세터를 알아서 제공
* 프로퍼티를 사용하려면 `val`(읽기 전용)과 `var`(읽기/쓰기 가능)을 사용해서 선언
* 만약 이름에 `is`가 들어간다면 게터에는 `get`이 붙지 않고 원래 이름을 사용, 세터에는 `is`를 `set`으로 바꾼 이름을 사용

### 2.2.2 커스텀 접근자

```kotlin
class Rectangle(val h: Int, val w: Int) {
    val isSquare: Boolean
	    get() h == w
}
```

* 게터나 세터를 위 예제 처럼 커스텀하게 사용 가능
* 커스텀한 게터는 해당 프로퍼티를 접근할 때마다 함수가 실행 
* 파라미터가 없는 함수를 정의하는 방식과 커스텀 게터를 정의하는 방식은 구현이나 성능상 차이는 없음, 가독성만 존재

### 2.2.3 코틀린 소스코드 구조: 디렉터리와 패키지

* 코틀린에도 자바와 같은 패키지 개념이 존재
* 자바와 같이 `import`를 사용하여 패키지를 가져옴
* `*` 스타 임포트를 사용하여 패키지 않에 있는 모든 클래스와 최상위에 정의된 함수와 프로퍼티를 다 불러옴
* 코틀린에서는 여러 클래스를 한 파일에 넣을 수 있고, 파일의 이름도 마음대로 정할 수 있음
* 디스크상의 어느 디렉터리에 소스코드 파일을 위치하든 관계 없음
* 여러 클래스를 한 파일에 넣는 것을 주저해서는 안되며 소스코드 크기가 아주 작은 경우 더욱 그러함

<br>

## 2.3 선택 표현과 처리: enum과 when

### 2.3.1 enum 클래스 정의

* 코틀린에서는 `enum`은 키워드가 아닌 소프트 키워드로 `class` 앞에 있을 때만 특별한 의미를 지님(`enum`이란 이름을 다른 곳에 사용 가능)
* `enum` 클래스 안에 프로퍼티 혹은 메소드를 정의 할 수 있음
* 프로퍼티와 메소드 사이에는 반드시 `;`가 필수

### 2.3.2 when으로 enum 클래스 다루기

```kotlin
fun getMnemonic(color: Color) = 
	when(color) {
        Color.RED -> "Richard"
        Color.ORANGE -> "Of"
        Color.YELLOW -> "York"
        Color.GREEN -> "Gave"
        Color.BLUE -> "Battle"
        Color.INDIGO -> "In"
        Color.VIOLET -> "Vain"
    }
```

* 자바의 `switch`문을 대신해서 코틀린에서는 `when`을 사용
* `if`와 마찬가지로 `when`도 값을 만들어내는 식
* 자바와는 달리 각 분기 끝에 `break`를 넣지 않아도 됨
* 한 분기 안에서 여러 값을 매치 패턴으로 사용 가능하며 `,`로 구분

### 2.3.3 when과 임의의 객체를 함께 사용

* 자바와는 달리 코틀린에서는 `when` 분기 조건은 임의의 객체를 허용
* 인자 값과 매치하는 조건 값을 검사할 때는 동등성을 사용

### 2.3.4 인자가 없는 when 사용

* 인자가 없는 `when`을 사용하면 불필요한 객체 생성을 막을 수 있음
* 인자가 없다면 각 분기의 조건이 불리언 결과를 계산하는 식이여야 함

### 2.3.5 스마트 캐스트: 타입 검사와 타입 캐스트를 조합

* 코틀린에서는 `is`를 사용하여 변수 타입을 검사
* 이는 자바의 `instanceof`와 비슷
* 타입을 비교하고 해당 값을 넣으려면 명시적으로 타입을 변경해야 하지만, 코틀린에서는 프로그래머 대신 컴파일러가 캐스팅을 대신 해줌, 이를 스마트 캐스트라고 함
* 스마트 캐스트의 경우 `is`로 변수에 든 값의 타입을 검사한 뒤 그 값을 바꿀 수 없을 때만 작동  
  이는 해당 값이 변경이 될 수 있다면 항상 같은 값을 내놓는다고 확신할 수 없기 때문
* 명시적으로 타입 캐스팅을 하려면 `as`를 사용

### 2.3.6 리팩토링: if를 when으로 변경

* `if`문도 분기문을 사용 `when`도 똑같으므로 대체가 가능
* `when`에서 분기문에 `else` 키워드 사용 가능

### 2.3.7 if와 when의 분기에서 블록 사용

* `if`문과 `when`문 모두 분기에 블록 사용가능하며 블록의 마지막 문장이 블록 전체의 결과가 됨
* 함수에는 해당 조건이 만족하지 않고 반드시 `return`문이 있어야 함

<br>

## 2.4 대상을 이터레이션: while과 for

* 코틀린의 `while` 루프는 자바와 동일
* `for`는 자바의 `for-each` 루프에 해당하는 형태만 존재이며 `for <아이템> in <원소들>` 형태를 취함

### 2.4.1 while 루프

> 생략

### 2.4.2 수에 대한 이터레이션: 범위와 수열

* 코틀린에는 초깃값, 증가 값, 최종 값과 같은 개념이 없으며 범위란 것을 사용

* 범위는 기본적으로 두 값으로 이루어진 구간이며, 보통 두 값은 정수 등의 숫자 타입의 값

* `..` 연산자로 시작 값과 끝 값을 연결해서 범위를 만듦

* 범위는 양끝을 포함하는 구간

  ```kotlin
  1..100 → 1부터 100까지 포함
  ```

* `downTo`를 사용하면 역방향 수열을 만들고 `step`을 사용하면 증가 폭을 바꿀 수 있음

* `until`을 사용하면 끝은 포함하지 않음

### 2.4.3 맵에 대한 이터레이션

* 범위 연산자는 숫자뿐만 아닌 문자 타입에도 적용 가능하며 맵도 사용 가능

  ```kotlin
  for((letter, binary) in binaryReps) {
      println("${letter} = ${binary}")
  }
  ```

* 키와 밸류를 구조 분해 구문을 사용하여 가져올 수 있으며, `map[key]= value`와 같이 사용이 가능

* 구조 분해 구문은 컬렉션에서도 활용 가능

  ```kotlin
  for((index, element) in list.withIndex()) {
      println("${index}: ${element}")
  }
  ```

### 2.4.4 in으로 컬렉션이나 범위의 원소 검사

* `in`을 사용하여 어떤 값이 범위에 속해 있는지 확인이 가능하며 `!in`을 사용하면 속하지 않음을 확인 가능
* 범위의 경우 문자도 되며, 비교가 가능한 클래스(`Comparable`을 구현한 클래스)라면 가능  
  하지만 이는 범위 내의 모든 객체를 항상 이터레이션하지는 못함

<br>

## 2.5 코틀린의 예외 처리

* 코틀린 또한 다른 언어의 예외 처리와 비슷
* 예외 인스턴스를 만들 때 `new` 키워드를 사용하지 않아도 됨
* 자바와는 달리 `throw`는 식으로 다른 식에 포함이 될 수 있음

### 2.5.1 try, catch, finally

* 자바와 똑같이 사용
* 자바와 달리 코틀린은 체크 예외를 명시적으로 처리하지 않아도 됨
* 자바 7의 `try-with-resource`는 코틀린에서 존재하지 않으며 라이브러리 함수로 같은 기능을 구현

### 2.5.2 try를 식으로 사용

* `try` 또한 식이며 다른 식과는 달리 반드시 `{}` 중괄호를 둘러싸야 함
* 본문에 여러 문장이 있다면 맨 마지막 식이 값 전체 결과 값
* `catch` 구문도 마찬가지

