![javascript](image/javascript.png)

<br>

# Javascript 동작 원리 - 엔진편

우리가 작성한 Javascript 코드는 어떻게 돌아가는 것일까?  
Javascript가 실행되기 위해 어떤 과정이 필요한지 알아보자.

Chrome에서 개발자 탭에서 Console 창을 키고 Javascript 코드를 작성하면 동작하는 것을 볼 수 있다.  
이는 Chrome에 Javascript 코드를 실행시킬 수 있는 엔진이 존재하는데 이를 **V8 엔진**이라고 한다.

Javascript 엔진 중 많이 알려져있는 V8은 Google의 주도하에 C++로 만들어진 고성능의 엔진이다.  
우리가 Javascript를 브라우저가 아닌 외부에서 실행 할 수 있도록 환경을 제공해주는 Node.js 또한 V8 엔진을 사용하고 있다.

이외에도 최초의 Javascript 엔진인 **SpiderMonkey**(Netscape, FireFox), 마이크로소프트에서 사용하는 **Chakra**(Edge) 등이 존재한다.

---

### 공통적인 과정

Javascript 엔진들은 코드를 기계어로 만들기까지의 과정에서 공통적인 부분과 다른 부분(최적화 관련)이 존재한다.  
우선, 공통적인 부분부터 짚고 넘어가자.

시작은 당연히 개발자가 작성한 코드부터이다.  
엔진에서는 코드를 파악하기 위해 파싱하여 Abstract Syntax Tree(AST, 추상 구문 트리)로 만든다.  
만든 AST를 가지고 인터프리터가 바이트 코드를 생성하며 생성된 바이트 코드로 실제 작동을 하게 된다.

이후 더 빠른 속도로 코드를 실행하기 위해 바이트 코드를 최적화 컴파일러로 보내, 최적화된 기계어를 생성하게 되는데 이 부분에서는 엔진마다 각기 다르다.

즉, 공통적인 부분에서는 다음과 같은 과정을 거친다.

1. 작성된 코드를 파싱하여 추상 구문 트리를 만든다.
2. 추상 구문 트리를 바탕으로 인터프리터가 바이트 코드를 생성하여 코드를 실행한다.

---

### 최적화 과정

각기 다른 엔진들의 최적화 과정을 보기전에 **인터프리터**와 **최적화 컴파일러**에 대해 먼저 짚고 넘어가자.

* 인터프리터 

  > 고급 언어로 작성된 원시코드 명령어들을 한번에 한줄씩 읽어 실행하는 프로그램이다. 고급 명령어들을 직접 기계어로 한번에 전부 번역하는 컴파일러와는 다르게 한 줄씩 번역한 뒤 바로 실행하기 때문에 번역 속도는 빠르나 실행 속도는 느리다.

* 최적화 컴파일러

  > 기본적인 컴파일러와 크게 다르진 않으나, 코드를 실행을 최적화 시키기 위해 필요한 시점에서 인터프리터가 해석한 바이트코드를 기반으로 컴파일하여 기계어 코드를 생성한다.

Javascript 엔진들은 보통 인터프리터를 사용하여 바이트코드를 생성하며, 최적화가 필요한 시점에서는 JIT(Just-In-Time) 모드를 실행하여 최적화 컴파일러를 통해 코드를 컴파일한다.  
최적화된 코드가 좋지않은 결과를 가져왔을 경우에는 다시 바이트코드로 되돌린다.

* JIT(Just-In-Time)

  > 동적 번역이라고도 불리우며 프로그램을 실제로 실행하는 시점에 기계어로 변역하여 컴파일하는 기법으로 프로그램의 실행 속도를 높히기 위해 사용된다.

<br>

#### 엔진별 최적화 과정

* **V8**

  V8에서는 **Ignition**이라는 인터프리터로 바이트코드를 생성 및 실행한다.  
  바이트코드가 실행될 때 Ignition은 프로파일링 데이터(최적화가 필요한 부분, 자주 사용되는 코드들)를 수집하여 최적화 컴파일러에게 보낸다.  
  이 최적화 컴파일러를 V8에서는 **TurboFan**이라고 한다.  
  최적화가 실패시에는 기계어에서 바이트코드로 되돌린다.

* **SpiderMonkey**

  SpiderMonkey에서 최적화 컴파일러는 두개다.  
  인터프리터가 생성한 바이트코드를 **Baseline** 컴파일러를 통해 약간의 최적화를 하며, 최적화된 코드를 실행하며 프로파일링 데이터를 수집한다.  
  수집된 프로파일링 데이터들을 합쳐 **IonMonkey**라는 최적화 컴파일러에게 보내고 고도로 최적화된 코드를 만들어 실행하게 된다.  
  최적화가 실패한다면, 바이트코드로 돌리는것이 아닌 Baseline 에서 나온 코드로 돌린다.

* **Chakra Core**
  Chakra Core에서도 SpiderMonkey와 마찬가지로 두개의 최적화 컴파일러를 가지고 있다.  
  다른점은, 바이트코드와 약간의 최적화된 코드(**Simple JIT**에서 나온 코드)에서 프로파일링 데이터를 **Full JIT** 이란 최적화 컴파일러에게 보내고 이를 고도로 최적화된 코드를 만든다.  
  최적화 실패시에는 바이트코드로 돌린다.

<br>

#### 공통점과 차이점

Javascript 엔진 별로 인터프리터를 사용하여 바이트코드를 생성, 이를 최적화 컴파일러에게 넘기는 등의 방식은 동일하나 코드의 최적화를 위해 인터프리터와 컴파일러 사이의 균형을 엔진별로 다른 방식을 사용하는 것이다.

<br>

#### 왜 이런 방식을 사용하는가?

여기서 의문점이 하나 생기게 되는데, "**왜 엔진들은 컴파일러만 사용해서 컴파일하지 않고 인터프리터를 사용했을까?**"

이유는 인터프리터가 가지고 있는 이점에 있다.  

* 기계어로 바로 컴파일하는 것보다 인터프리터로 바이트코드를 생성하는것이 메모리 사용량이 적다.
* 바이트코드는 기계어보다 간결하기 때문에 파싱시에 오버헤드가 작다.
* 최적화 혹은 다시 돌리는 과정에서 바이트코드 하나만 생각하면 되기에 컴파일 파이프 라인의 복잡성이 감소한다.

또한 Javascript에서는 다른 언어와 다르게 자료형이 실행 시점에서 동적으로 할당되기에 기계어로 컴파일시에는 해당 자료형을 유추하기가 바이트코드에 비해 어렵다는 이유도 존재한다.

---

<br>

<br>

### Reference

* [컴파일러와 인터프리터란 무엇인가?](https://coding-factory.tistory.com/303)
* [위키백과-인터프리터](https://ko.wikipedia.org/wiki/인터프리터)
* [JavaScript 엔진 톺아보기](https://velog.io/@godori/JavaScript-engine-1)