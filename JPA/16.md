# 16.트랜잭션과 락, 2차 캐시

> 🧟‍♀️ 이 글은 김영한님의 ['자바 ORM 표준 JPA 프로그래밍'](https://www.inflearn.com/course/ORM-JPA-Basic)을 공부하며 정리한 것임을 알립니다.

<br>

## 16.1 트랜잭션과 락

### 16.1.1 트랜잭션과 격리 수준

* 트랜잭션은 ACID라 하는 원자성(Atomicity), 일관성(Consistency), 격리성(Isolation), 지속성(Durability)를 보장
* 트랜잭션 간에 격리성을 완벽히 보장하려면 트랜잭션을 거의 차례대로 실행하기 때문에 동시성 처리 성능이 나쁨
* 따라서 다음과 같은 ANSI 표준은 트랜잭션 격리 수준을 4단계로 나눔
  * READ UNCOMMITED
  * READ COMMITTED
  * REPEATABLE READ
  * SERIALIZABLE
* 격리 수준이 낮을수록 동시성은 증가하지만 격리 수준에 따른 다양한 문제 발생
* 최근에는 데이터베이스들이 더 많은 동시성 처리를 위해 락보다는 MVCC(Mutiversion Concurrency Control)를 사용하므로 락을 사용하는 데이터베이스와는 약간 다를 수 있음

### 16.1.2 낙관적 락과 비관적 락 기초

* 영속성 컨텍스트를 적절히 활용하면 데이터베이스 트랜잭션이 READ COMMITTED 격리 수준에서도 REPEATABLE READ가 가능(엔티티가 아닌 스칼라 값을 직접 조회시에는 제외)

* JPA는 데이터베이스 트랜잭션 격리 수준을 READ COMMITTED 정도로 가정하며, 일부 로직에 더욱 높은 격리 수준이 필요하다면 **낙관적 락**과 **비관적 락** 중 하나를 사용

* 낙관적 락

  * 이름 그대로 트랜잭션 대부분 충돌이 발생하지 않다고 낙관적으로 가정하는 방법

  * JPA(애플리케이션)가 제공하는 버전 관리 기능을 사용
  * 트랜잭션을 커밋하기 전까지 충돌을 알 수 없음

* 비관적 락

  * 트랜잭션의 충돌이 발생할 수 있다고 가정하고 우선 락을 걸고 보는 방법
  * 데이터베이스가 제공하는 락 기능을 사용
  * 대표적으로 SELECT FOR UPDATE

* **두 번의 갱신 분실 문제**라는 트랜잭션 범위를 넘어서는 문제도 존재

  > 두 번의 갱신 분실 문제
  >
  > A와 B가 같은 데이터를 수정하기 위해서 동시에 작업 도중 먼저 A가 완료하여 수정하였고, B가 그다음으로 완료했다면 또 한번 수정되어 B의 내용만 남는 문제
  >
  > 이를 해결하기 위해서는 3가지 방법이 존재
  >
  > 1. 마지막 커밋만 인정(기본)
  > 2. 첫번째 커밋만 인정
  > 3. 충돌하는 갱신 내용 병합(개발자가 직접 사용자를 위해 방법 제공)

### 16.1.3 @Version

* JPA가 제공하는 낙관적 락을 사용하기 위해서는 `@Version` 어노테이션을 사용하여 버전 관리 기능을 추가

* 타입은 `Long`, `Integer`, `Short`, `Timestamp` 가능

* 엔티티를 수정할 때마다 버전이 하나씩 자동으로 증가, 만약 수정시 조회 시점의 버전과 다르다면 예외 발생

* 이를 통해 **최초 커밋만 인정**하기가 적용

* 버전 정보 비교 방법

  * 비교하는 방법은 단순

  * 엔티티를 수정하고 트랜잭션을 커밋하면 영속성 컨텍스트를 플러시 하면서 UPDATE 쿼리를 실행

  * 버전을 사용하는 엔티티면 검색 조건에 엔티티의 버전 정보를 추가

    `UPDATE OOO SET TITLE=?, VERSION=? WHERE ID=? AND VERSION=?`

  * 만약 버전이 다르다면 WHERE절에 걸리지 않으므로 대상이 없으며 예외 발생

  * 임베디드 타입과 값 타입 컬렉션은 논리적인 개념상 해당 엔티티의 값이므로 수정하면 버전이 증가  
    연관관계 필드는 외래 키를 관리하는 연관관계의 주인 필드를 수정할 때만 버전 증가

  * 버전은 JPA가 직접 관리하므로 개발자가 임의로 수정하면 안됨(벌크 연산 제외)

### 16.1.4 JPA 락 사용

* JPA를 사용할 때 추천 전략은 READ COMMITTED 트랜잭션 격리 수준과 낙관적 버전 관리
* 락은 `EntityManager.lock()`, `EntityManager.find()`, `EntityManager.refresh()`, `Query.setLockMode()`, `@NamedQuery` 에 적용 가능
* 락 옵션은 `javax.persistence.LockModeType`에 정의

### 16.1.5 JPA 낙관적 락

* 낙관적 락은 버전을 사용

* 트랜잭션을 커밋하는 시점에 충돌을 알 수 있음

* 일부 JPA 구현체 중에는 버전 없이도 낙관적락을 허용하지만 추천 X

* 락 옵션 없이 `@Version` 만 존재해도 낙관적 락이 적용, 세밀하게 제어하고 싶다면 옵션 사용

* NONE
  * 락 옵션을 적용하지 않아도 엔티티에 `@Version`이 적용된 필드만 있다면 낙관적 락이 적용

  * **용도**

    조회한 엔티티를 수정할 때 다른 트랜잭션에 의해 변경되지 않아야 할 때

  * **동작**

    엔티티를 수정할 때 버전 체크하면서 증가, 수정 시 버전이 다를 때는 예외 발생

  * **이점**

    두 번의 갱신 분실 문제를 예방

* OPTIMISTIC

  * 엔티티를 조회만 해도 버전을 체크, 한 번 조회한 엔티티는 트랜잭션을 종료할 때까지 다른 트랜잭션에서 변경하지 않음을 보장

  * **용도** 

    조회한 엔티티는 트랜잭션이 끝날 때까지 다른 트랜잭션에 의해 변하면 안될 때

  * **동작**

    트랜잭션을 커밋할 때 버전 정보를 조회해서 현재 엔티티의 버전과 같은지 검증, 같지 않으면 예외 발생

  * **이점**

     DIRTY READ와 NON-REPEATABLE READ 방지

* OPTIMISITC_FORCE_INCREMENT

  * 낙관적 락을 사용하면서 버전 정보를 강제로 증가

  * **용도**

    논리적은 단위의 엔티티 묶음을 관리할 때  
    즉, 연관관계에서 주인이 아닌 엔티티를 수정할 때 주인인 곳의 버전을 증가살 수 있음

  * **동작**

    엔티티를 수정하지 않아도 트랜잭션을 커밋할 때 UPDATE 쿼리를 사용해서 버전 정보를 강제로 증가

### 16.1.6 JPA 비관적 락

* 비관적 락은 데이터베이스 트랜잭션 락 메커니즘에 의존하는 방법
* 주로 SQL 쿼리에 SELECT FOR UPDATE 구문을 사용하면서 시작하고 버전 정보는 사용하지 않음
* 주로 PESSIMISTIC_WRITE 모드를 사용
* 엔티티가 아닌 스칼라 타입을 조회할 때도 사용 가능
* 데이터를 수정하는 즉시 트랜잭션 충돌 감지
* PESSIMISTIC_WRITE
  * 일반적인 비관적 락은 해당 옵션을 뜻함
  * 데이터 베이스에 쓰기 락을 걸 때 사용
  * 데이터베이스 SELECT FOR UPDATE를 사용하여 락을 걸음
  * NON-REPEATABLE READ를 방지
* PESSIMISTIC_READ
  * 반복 읽기만 하고 수정하지 않는 용도로 락을 걸 때 사용
  * 일반적으로 잘 사용하지 않음
  * 대부분 방언에 의해 PESSIMISTIC_WRITE로 동작
* PESSIMISTIC_FORCE_INCREMENT
  * 비관적 락중 유일하게 버전 정보를 사용
  * 버전 정보를 강제로 증가
  * 하이버네이트는 NOWAIT를 지원하는 데이터베이스에 대해서 UPDATE NOWAIT 옵션을 적용

### 16.1.7 비관적 락과 타임아웃

* 락을 획득할 때까지 트랜잭션이 대기
* 무한정 기다릴 수는 없으므로 타임아웃 시간을 줄 수 있음
* 데이터베이스 특성에 따라 동작하지 않을 수 있음

<br>

## 16.2 2차 캐시

### 16.2.1 1차 캐시와 2차 캐시

* 데이터베이스에 직접 접근하는 비용은 굉장히 비싸기에 이를 줄이기 위해 캐시를 사용하면 성능을 획기적으로 개선
* 일반적인 웹 애플리케이션 환경은 트랜잭션을 시작하고 종료할 때까지만 1차 캐시가 유효
* OSIV를 사용해도 클라이언트의 요청이 끝날 때까지만 유효
* 이 때문에 데이터베이스 접근 횟수를 획기적으로 줄이지는 못함
* 애플리케이션 범위의 캐시를 지원하는데 이것을 공유 캐시 또는 2차 캐시라고 함
* 1차 캐시
  * 1차 캐시에 엔티티가 존재하면 그대로 반환, 객체의 동일성을 보장
  * 기본적으로 영속성 컨텍스트 번위의 캐시
* 2차 캐시
  * 애플리케이션 범위의 캐시로 애플리케이션이 종료될 때까지 유지
  * 분산 캐시나 클러스터링 환경의 캐시는 애플리케이션보다 더 오래 유지 가능
  * 데이터를 조회할 때 우선 2차 캐시에서 찾고 없다면 데이터베이스에 찾음
  * 동작 방식
    1. 영속성 컨텍스트는 엔티티가 필요하면 2차 캐시를 조회
    2. 2차 캐시에 엔티티가 없으면 데이터베이스를 조회
    3. 결과를 2차 캐시에 보관
    4. 자신이 보관하고 있는 엔티티를 복제해서 반환
    5. 2차 캐시에 보관되 있는 엔티티를 조회하면 복사본을 만들어 반환
  * 복사본을 만들어 반환하는 것은 동시성을 극대화하기 위함  
    만약 1차 캐시처럼 그냥 반환하면 여러 곳에서 동시에 수정할 때 문제가 발생  
    객체에 락을 걸어두면 동시성이 떨어질 수 있음
  * 따라서 2차 캐시는 데이터베이스 기본키를 기준으로 캐시는 하지만 영속성 컨텍스트가 다르다면 객체 동일성을 보장할 수 없음

### 16.2.2 JPA 2차 캐시 기능

* 2.0에 와서야 2차 캐시 표준을 정의

* 캐시 모드 설정

  * 2차 캐시를 사용하기 위해서는 `@Cacheable` 어노테이션을 사용(기본값은 true)

    ```java
    @Cacheable
    @Entity
    public class Member {
        ...
    }
    ```

  * persistence.xml에 `shard-cache-mode`를 설정하여 애플리케이션 전체에 어떻게 적용할지 옵션을 설정

  * 캐시 모드의 경우, `javax.persistence.SharedCacheMode`에 정의, 보통 ENABLE_SELECTIVE 사용

    | 캐시모드          | 설명                                                         |
    | ----------------- | ------------------------------------------------------------ |
    | ALL               | 모든 엔티티를 캐시                                           |
    | NONE              | 캐시를 사용하지 않음                                         |
    | ENABLE_SELECTIVE  | Cachable(true)로 설정한 엔티티만 캐시 적용                   |
    | DISABLE_SELECTIVE | 모든 엔티티를 캐시하는데 Cacheable(false)라고 명시된 엔티티는 캐시 X |
    | UNSPECIFIED       | JPA 구현체가 정의한 설정을 따름                              |

* 캐시 조회, 저장 방식 설정

  * 캐시를 무시하고 직접 조회하거나 갱신하려면 캐시 조회 모드와 보관 모드를 사용
  * 캐시 조회 모드
    * javax.persistence.cache.retrieveMode(프로퍼티 이름) 사용
    * javax.presistence.CacheRetrieveMode(설정 옵션)
      * USE: 캐시에서 조회(기본값)
      * BYPASS: 캐시를 무시하고 데이터베이스에 직접 접근
  * 캐시 보관 모드
    * javax.persistence.cache.storeMode(프로퍼티 이름) 사용
    * javax.presistence.CacheStoreMode(설정 옵션)
      * USE: 조회한 데이터가 있다면 캐시 데이터를 최신 상태로 갱신하지 않음, 트랜잭션을 커밋하면 등록 수정한 엔티티도 캐시에 저장(기본값)
      * BYPASS: 캐시에 저장하지 않음
      * REFRESH: USE 전략에 추가로 데이터베이스에서 조회한 엔티티를 최신 상태로 다시 캐시

* JPA 캐시 관리 API

  * 캐시를 관리하기 위한 `javax.persistence.Cache` 인터페이스 제공

### 16.2.3 하이버네이트와 EHCACHE 적용

* 하이버네이트가 지원하는 캐시는 크게 3가지가 존재

  1. 엔티티 캐시

     > 엔티티 단위로 캐시  
     > 식별자로 엔티티를 조회하거나 컬렉션이 아닌 연관된 엔티티를 로딩할 때 사용

  2. 컬렉션 캐시(하이버네이트 기능)

     > 엔티티와 연관된 컬렉션을 캐시  
     > 컬렉션이 엔티티를 담고 있으면 식별자 값만 캐시

  3. 쿼리 캐시(하이버네이트 기능)

     > 쿼리와 파라미터 정보를 키로 사용해서 캐시  
     > 결과가 엔티티면 식별자 값만 캐시

* EHCACHE는 ehcache.xml을 설정 파일로 사용하며, 캐시 정책을 정의하는 설정 파일(`/resources` 밑에 바로)

  * use_second_level_cache : 2차 캐시를 활성화, 엔티티 캐시와 컬렉션 캐시를 사용 가능
  * use_query_cache : 쿼리 캐시를 활성화
  * factory_class : 2차 캐시를 처리할 클래스를 지정, EHCACHE는 `org.hibernate.cache.ehcache.EhCacheRegionFactory`를 적용
  * generate_statistics : 해당 속성을 true로 하면 하이버네이트가 여러 통계정보를 출력해줌

* 엔티티 캐시와 컬렉션 캐시

  * `@Cacheable` 어노테이션을 사용하면 엔티티 캐시 가능
  * `@Cache` 어노테이션은 하이버네이트 전용으로 캐시와 관련된 세밀한 설정을 할 때 사용, 컬렉션 캐시를 적용할 때도 사용

* `@Cache`

  * 속성

    | 속성    | 설명                                                      |
    | ------- | --------------------------------------------------------- |
    | usage   | CacheConcurrencyStrategy를 사용하여 캐시 동시성 전략 설정 |
    | region  | 캐시 지역 설정                                            |
    | include | 연관 객체를 캐시에 포함할지 선택(all, non-lazy)           |

  * CacheConcurrencyStrategy

    | 속성                 | 설명                                                         |
    | -------------------- | ------------------------------------------------------------ |
    | NONE                 | 캐시를 설정하지 않음                                         |
    | READ_ONLY            | 읽기 전용 설정  <br />하이버네이트는 2차 캐시를 조회할 때 객체를 복사하지 않고 원본 객체 반환 |
    | NONSTRICT_READ_WRITE | 엄격하지 않은 읽고 쓰기 전략  <br />동시에 같은 엔티티를 수정하면 데이터 일관성이 깨질 수 있으므로 EHCACHE는 데이터를 수정하면 캐시 데이터를 무효화 |
    | READ_WRITE           | 읽기 쓰기가 가능하고 READ COMMITTED 정도의 격리 수준을 보장  <br />EHCACHE는 데이터를 수정하면 캐시 데이터도 같이 수정 |
    | TRANSACTIONAL        | 컨테이너 관리 환경에서 사용  <br />설정에 따라 REPEATABLE READ 정도의 격리 수준을 보장 |

* 캐시 영역

  * 캐시를 적용한 코드는 다음 캐시 영역에 저장
    * 엔티티 캐시 영역 : 패키지 명 + 클래스 명
    * 컬렉션 캐시 영역 : 패키지 명 + 클래스 명 + 컬렉션의 필드 명
  * 캐시 영역을 위한 접두사를 설정하려면 persistence.xml 설정에 `hibernate.cache.region_prefix`를 사용
  * 캐시 영역이 정해져 있으므로 영역별로 세부 설정이 가능

* 쿼리 캐시

  * 쿼리와 파라미터 정보를 키로 사용해서 쿼리 결과를 캐시하는 방법
  * 영속성 유닛을 설정에 `hibernate.cache.use_query_cache` 옵션을 꼭 true로 설정
  * 쿼리 캐시를 적용하려는 쿼리마다 `org.hibernate.cacheable`을 true로 설정하는 힌트를 주면 됨

* 쿼리 캐시 영역

  * 쿼리 캐시를 활성화하면 두 캐시 영역이 추가

    * StandardQueryCache

      > 쿼리 캐시를 저장하는 영역  
      > 쿼리, 쿼리 결과 집합, 쿼리를 실행한 시점의 타임스탬프를 저장

    * UpdateTimestampCache

      > 쿼리 캐시가 유효한지 확인하기 위해 쿼리 대상 테이블의 가장 최근 변경 시간을 저장하는 영역  
      > 테이블 명과 해당 테이블의 최근 변경된 타입 스탬프를 보관

  * 쿼리 캐시는 캐시한 데이터 집합을 최신 데이터로 유지하려고 쿼리 캐시를 실행하는 시간과 쿼리 캐시가 사용하는 테이블들이 가장 최근에 변경된 시간을 비교

  * 쿼리 캐시가 적용되고 난 뒤에 테이블에 조금이라도 변경이 일어났다면 쿼리 결과를 다시 캐시

  * 동작 방식

    1. 쿼리 실행시 우선 StandardQueryCache 캐시 영역에서 타임스탬프를 조회
    2. 쿼리 가 사용하는 엔티티의 테이블을 UpdateTimestampCache 캐시 영역에서 조회
    3. 타임스탬프를 비교하고 StandardQueryCache 캐시 영역이 오래되었다면 다시 데이터 조회

  * 쿼리 캐시를 잘 활용하면 극적인 성능 향상이 있지만 빈번히 변경이 있는 테이블에 사용하면 오히려 저하

* 쿼리 캐시와 컬랙션 캐시의 주의점

  * 쿼리 캐시와 컬렉션 캐시는 결과 집합의 식별자 값만 캐시
  * 해당 식별자를 통해 엔티티 캐시에서 조회하여 실제 데이터를 찾는 방식
  * 만약 쿼리 캐시와 컬렉션 캐시만 사용하고 대상 엔티티에 엔티티 캐시를 적용하지 않으면 문제 발생(엔티티 캐시에 없다면 결국 SQL문이 실행되기 때문)
  * 따라서 쿼리 캐시와 컬렉션 캐시 사용한다면 대상 엔티티에 꼭 엔티티 캐시를 적용